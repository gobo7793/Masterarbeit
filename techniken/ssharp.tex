\section{\sS}\label{sec:sSharp}

Wie in \autoref{sec:problemstellung} erwähnt, wird am Lehrstuhl das Framework \sS entwickelt. Da es in \cS entwickelt wurde und \cS auch zum Entwickeln von Modellen und dazugehörigen Testszenarien genutzt wird, können zahlreiche Features des .NET-Frameworks bzw. der Sprache \cS im Speziellen genutzt werden. \sS vereint dabei die Simulation, die Visualisierung, modellbasierte Tests sowie das MC der Modelle \cite{Habermaier2015,Habermaier2016}. Dadurch können alle Schritte einer vollständigen Analyse inkl. Modellierung direkt im Visual Studio ausgeführt werden und somit auch alle Features der IDE und von .NET, wie \zB die Debugging-Werkzeuge, genutzt werden. Um das MC durchzuführen, hat \sS jedoch einige Einschränkungen, \uA sind Schleifen und Rekursionen nur eingeschränkt bzw. nicht möglich. Die größte Einschränkung ist allerdings, dass während der Laufzeit keine neuen Objektinstanzen erzeugt werden können, sodass alle benötigten Instanzen bereits während der Initialisierung des Modells erzeugt werden müssen \cite{Habermaier2015}.

Um nun ein System testen zu können, muss dieses zunächst mithilfe von \cS-Klassen und -Instanzen modelliert werden. Die dafür verwendeten Modelle sind meist stark vereinfacht und bilden nur die wesentlichen Aspekte der realen Systeme ab. Für einen korrekten Test ist es jedoch wichtig, dass das Modell des Systems vergleichbar mit dem echten System ist.

\lstinputlisting[label=lst:ssExample,caption={Grundlegender Aufbau einer \sS-Komponente},float]
{listings/ssExample.cs}

\autoref{lst:ssExample} zeigt den typischen, grundlegenden Aufbau einer \sS-Komponente. Jede Komponente des Modells muss von \texttt{Component} erben, um als \sS-Komponente definiert zu sein. Jede Komponente kann nun temporäre (\texttt{TransientFault}) oder dauerhafte (\texttt{PermanentFault}) Komponentenfehler enthalten, welche zunächst innerhalb der Komponente definiert werden. Der Effekt eines Komponentenfehlers wird anschließend in der entsprechenden Unterklasse definiert, welche von der Hauptklasse (hier \texttt{YarnNode}) erbt und mithilfe des Attributs \texttt{FaultEffect} dem dazugehörigen Komponentenfehler zugeordnet wird \cite{Habermaier2016}.

Um die Modelle zu testen, kommt in \sS die \textit{Deductive Cause-Consequence Analysis} (DCCA) zum Einsatz. Die DCCA ermöglicht eine vollautomatisch und MC-basierte Sicherheitsanalyse, wodurch selbstständig die Menge der aktivierten Komponentenfehler ermittelt wird, mit denen sich das Gesamtsystem nicht mehr rekonfigurieren kann und somit ausfällt. Je nach Konfiguration können dazu auch Heuristiken genutzt werden, welche die Analyse beschleunigen und genauer machen können \cite{Eberhardinger2016}. Dabei werden die verschiedenen aktivierten Komponentenfehler während der Analyse in tolerierbare und nicht-tolerierbare Fehler unterschieden. Tolerierbare Komponentenfehler werden dazu genutzt, die Grenzen der Selbstkonfiguration des Systems zu ermitteln. Dabei wird für jeden Systemzustand nach einer Rekonfiguration durch die DCCA eine neue Fehlermenge ermittelt, mit der das System gerade noch so lauffähig ist. Das Auftreten eines tolerierbaren Komponentenfehler ist also gleichbedeutend mit einem einfachen Fehler im System, welcher die gesamte Funktionsweise des Systems nicht massiv einschränkt und es sich noch selbst rekonfigurieren kann. Sobald jedoch ein Fehler auftritt, durch den es dem System nicht mehr möglich ist, sich selbst zu rekonfigurieren, wurde ein nicht-tolerierbarer Fehler gefunden, durch den das System nicht mehr funktionsfähig ist \cite{Habermaier2015}.