\section{Implementierung der Anwendungen im Modell}
\label{sec:appImplementation}

Die Verwaltung der auszuführenden Benchmarks wurde komplett vom restlichen YARN"=Modell getrennt.
Verbunden sind beide durch die Eigenschaft \texttt{Client.BenchController}, das den vom Client verwendeten \texttt{BenchmarkController} enthält, der zur Verwaltung der auszuführenden Anwendung dient.
Der Controller besteht aus zwei wesentlichen Teilen, einem statischen und einem dynamischen.

Der \textbf{statische Teil} des Controllers definiert die möglichen Anwendungen sowie das im Abschnitt zuvor definierte und in \cref{tab:transMatrix} dargestellte Transitionssystem.
Die einzelnen Anwendungen werden mithilfe der Klasse \texttt{Benchmark} repräsentiert, in der die benötigten Informationen wie \zB der Befehl zum Starten der Anwendung definiert werden.
Da mehrere Clients unabhängig voneinander agieren können müssen, erhält jeder Client zudem ein eigenes Unterverzeichnis im \ac{HDFS}, in dem sich die Ein- und Ausgabeverzeichnisse für die von ihm gestarteten Anwendungen befinden.
Das muss auch bei der Definition der Startbefehle der Anwendungen berücksichtigt werden, weshalb in \cref{lst:benchmarkDefinition} entsprechende Platzhalter vorhanden sind.
Aus diesem Grund muss vor dem Start der Anwendung mithilfe der Methode \texttt{GetStartCmd()} der Startbefehl generiert werden, indem der zu startende Client das in \texttt{Client.ClientDir} gespeicherte Client"=Basisverzeichnis übergibt.
Da einige Anwendungen zudem voraussetzen, dass das genutzte Ausgabe"=Verzeichnis noch nicht im \ac{HDFS} existiert, muss das Verzeichnis vor dem Anwendungsstart gelöscht werden.

Jede Anwendung erhält zudem eine eigene ID, die mit ihrem Index im Array \texttt{BenchmarkController.Benchmarks} übereinstimmt.
Diese wird bei der in \cref{lst:benchmarkChanging} dargestellte Auswahl der nachfolgenden Anwendung benötigt, um innerhalb des gesamten Transitionssystems in \texttt{BenchmarkController.BenchTransitions} die Wahrscheinlichkeiten für die Wechsel von der derzeitigen Anwendung zu anderen Anwendungen auszuwählen.

\begin{lstlisting}[label=lst:benchmarkDefinition,style=cs,
caption={[Definition und Start einer Anwendung]
    Definition und Start einer Anwendung (gekürztes Beispiel).
    Die Generierung des komplettes Startbefehls mit Nutzung des Benchmark"=Scriptes führt der vom Client verwendete Connector durch, weshalb hier nur definiert werden muss, dass das Example"=Programm \acl{wc} gestartet wird.}]
public class Benchmark
{
  public const string BaseDirHolder = "$DIR";
  public const string OutDirHolder = "$OUT";
  public const string InDirHolder = "$IN";
  
  public Benchmark(int id, string name, string startCmd, string outputDir, string inputDir)
  {
    _StartCmd = startCmd;
    _InDir = inputDir;
    HasInputDir = true;
  }
  
  public string GetStartCmd(string clientDir = "")
  {
    var result = _StartCmd.Replace(OutDirHolder, GetOutputDir(clientDir)).Replace(InDirHolder, GetInputDir(clientDir));
    if(result.Contains(BaseDirHolder))
    result = ReplaceClientDir(result, clientDir);
    return result;
  }
}

using static Benchmark;
public class BenchmarkController
{
  
  public static Benchmark[] Benchmarks { get; } // benchmarks
  public static int[][] BenchTransitions { get; } // transitions
  
  static BenchmarkController()
  {
    Benchmarks = new[]
    {
      new Benchmark(04, "wordcount", $"example wordcount {InDirHolder} {OutDirHolder}", $"{BaseDirHolder}/wcout", $"{BaseDirHolder}/rantw"),
    };
  }
}

public class Client : Component
{
    public string StartBenchmark(Benchmark benchmark)
    {
        if(benchmark.HasOutputDir)
        SubmittingConnector.RemoveHdfsDir(benchmark.GetOutputDir(ClientDir));
        var appId = SubmittingConnector.StartApplicationAsync(benchmark.GetStartCmd(ClientDir));
    }
}
\end{lstlisting}

Der \textbf{dynamische Teil} des Controllers ist für die Auswahl der auszuführenden Anwendung zuständig, was auch die Auswahl der initial auszuführenden Anwendung einschließt.
Zur Auswahl der initialen Anwendung wird basierend auf der \acl{sl}"=Anwendung das Transitionssystem genutzt und so eine Anwendung ausgewählt, die keine Eingabedaten benötigt bzw. diese für andere Anwendungen generiert.

Das im vorherigen Abschnitt definierte und im statischen Teil implementierte Transitionssystem kommt auch immer dann zum Einsatz, wenn Entschieden werden muss, welche Anwendung der derzeit ausgeführten Anwendung folgt.
Jeder Client bzw. sein \texttt{BenchmarkController} entscheidet unabhängig von anderen Clients einmal pro \sS-Takt, welche Anwendung ausgeführt wird.

\begin{lstlisting}[label=lst:benchmarkChanging,style=cs,
caption={[Normalisierung und Auswahl der nachfolgenden Anwendung]
    Normalisierung und Auswahl der nachfolgenden Anwendung (gekürzt)}]
// get probabilities from current benchmark
var transitions = BenchTransitions[CurrentBenchmark.Id];

var ranNumber = RandomGen.NextDouble();
var cumulative = 0D;
for(int i = 0; i < transitions.Length; i++)
{
  cumulative += transitions[i];
  if(ranNumber >= cumulative)
  continue;
  
  // save benchmarks
  PreviousBenchmark = CurrentBenchmark;
  CurrentBenchmark = Benchmarks[i];
}
\end{lstlisting}

Nachdem eine neue Anwendung ausgewählt wurde, muss zunächst sichergestellt werden, dass die bisher ausgeführte Anwendung beendet ist.
Dafür wird der in \cref{lst:hadoopAppKill} dargestellte Befehl von Hadoop zum Abbruch von Anwendungen ausgeführt, wodurch die derzeit ausgeführte Anwendung beendet wird, sollte sie noch nicht abgeschlossen sein.
Im Anschluss kann das von der neuen Anwendung benötigte \ac{HDFS}"=Ausgabeverzeichnis gelöscht werden, bevor die Anwendung selbst gestartet wird.

Eine Anwendung wird wie in \cref{lst:benchmarkDefinition} gezeigt zwar asynchron gestartet, allerdings wird zunächst noch synchron auf die Ausgabe der \texttt{applicationId} gewartet.
Die gesamte Ausgabe einer zu startenden Anwendung ist in \cref{lst:hadoopAppStart} zu finden.
Die ID wird vom Cluster im Rahmen der Übergabe und Initialisierung der Anwendung vergeben.
Erst nachdem diese bekannt ist, wird die restliche Ausführung der Anwendung asynchron durchgeführt.
Benötigt wird die ID damit der zu startende Client die Anwendung im Falle eines Anwendungswechsels in den folgenden Takten beenden kann.
Ohne die direkte Speicherung der ID wäre es sonst nicht möglich, klar entscheiden zu können, welchem Client die Anwendung zugeordnet ist.
Dies ist auch der Grund, weshalb kein HiBench"=Workload in das Transitionssystem aufgenommen wurde, da hier die \texttt{applicationId} gemeinsam mit der gesamten Ausgabe der einzelnen HiBench"=Anwendungen erst nach Abschluss der Ausführung ausgegeben wird.
Gespeichert wird die ID zunächst in einer noch verfügbaren \texttt{YarnApp}"=Instanz, welche anschließend selbst in \texttt{Client.CurrentExecutingApp} gespeichert wird.
