\section{Entwicklung des Benchmark"=Controllers}
\label{sec:benchmarkController}

Die im \gls{YARN}"=Modell (vgl. \cref{sec:yarnModel}) implementierten Benchmarks und das zur Auswahl der Benchmarks entwickelte Transitionssystem bilden zusammen den Benchmark"=Controller.
Der Benchmark"=Controller wurde als eigene Klasse \texttt{BenchmarkController} im Modell implementiert und wird von den Clients genutzt, um die Auswahl der Benchmarks vorzunehmen.
Der Benchmark"=Controller verwaltet die implementierten Benchmarks und stellt diese den Clients zum Starten zur Verfügung (vgl. \cref{subsec:yarnClient}).
Damit die Clients unabhängig voneinander sind, wird für jeden Client ein eigener Benchmark"=Controller instanziiert.

\subsection{Implementierung von Benchmarks und Transitionssystem}
\label{subsec:appImplementation}

Die Benchmarks wurden mithilfe der Klasse \texttt{Benchmark} implementiert.
Sie enthält alle zur Ausführung der Benchmarks benötigten Informationen und stellt diese der \texttt{BenchmarkController}"=Klasse bzw. dem Client bereit, um die \gls{Anwendung} des Benchmarks zu starten.
Da mehrere Clients unabhängig voneinander agieren können müssen, erhält jeder Client ein spezifisches Unterverzeichnis im \gls{HDFS}, in dem sich die Ein- und Ausgabeverzeichnisse für die von ihm gestarteten \glspl{Anwendung} befinden.
Das muss auch bei der Definition der Startbefehle der \glspl{Anwendung} berücksichtigt werden, weshalb hierfür entsprechende Platzhalter ersetzt werden müssen, wenn mithilfe der Methode \texttt{GetStartCmd()} der Start"=Befehl des Benchmarks zurückgegeben wird:

\begin{lstlisting}[label=lst:benchmarkClass,style=cs,
caption={[Wesentliche Methoden der Klasse Benchmark]
    Wesentliche Methoden der Klasse \texttt{Benchmark}}]
public class Benchmark
{
  public Benchmark(int id, string name, string startCmd, string outputDir, string inputDir)
  {
    _StartCmd = startCmd;
    _InDir = inputDir;
    HasInputDir = true;
  }
  
  public string GetStartCmd(string clientDir = "")
  {
    var result = _StartCmd.Replace(OutDirHolder, GetOutputDir(clientDir)).Replace(InDirHolder, GetInputDir(clientDir));
    if(result.Contains(BaseDirHolder))
      result = ReplaceClientDir(result, clientDir);
    return result;
  }
}
\end{lstlisting}

Alle im Modell enthaltenen Benchmarks sind als Array im \texttt{BenchmarkController} gespeichert.
Hier werden auch die benötigten Befehle zum Starten der \glspl{Anwendung} der Benchmarks definiert:

\begin{lstlisting}[label=lst:benchmarkDefinition,style=cs,
caption={[Definition der verfügbaren Benchmarks im BenchmarkController]
    Definition der verfügbaren Benchmarks im \texttt{BenchmarkController} (gekürzt)}]
public Benchmark[] Benchmarks => new[]
{
  new Benchmark(04, "wordcount", $"example wordcount {InDirHolder} {OutDirHolder}", $"{BaseDirHolder}/wcout",
};
\end{lstlisting}

Der hierbei definierte und durch \texttt{GetStartCmd()} zurückgegebene vollständige Startbefehl wird beim Starten der \glspl{Anwendung} vom Connector als Befehlsparameter dem Benchmark"=Script angehängt (vgl. \cref{subsubsec:implCmdConnector}).
Damit kann durch das Benchmark"=Script die zu startende \gls{Anwendung} identifiziert und das jeweilige Start"=Script ausgeführt werden (vgl. \cref{subsec:scripts}).

Das Transitionssystem selbst wurde im \texttt{BenchmarkController} als zweidimensionaler Array implementiert, auf das mithilfe von \texttt{Benchmark.ID} zugegriffen werden kann.
Entsprechend wichtig ist hierbei die Reihenfolge der jeweiligen Werte innerhalb des Arrays, welche immer gleich sein muss mit den jeweiligen IDs:

\begin{lstlisting}[label=lst:transitionSystemImpl,style=cs,
caption={[Implementierung des Transitionssystems im BenchmarkController]
    Implementierung des Transitionssystems im \texttt{BenchmarkController} (gekürzt)}]
public double[][] BenchTransitions => new[]
{
  /* f§§rom / to ->    00    01   02   ...*/
  /* f§§rom / to ->   dfw   rtw   tg   ...*/
  new[] /* 00 */ { .600, .073,  000, ... ,
  new[] /* 01 */ { .036, .600,  000, ... ,
  new[] /* 02 */ {  000, .036, .600, ... ,
};
\end{lstlisting}

\subsection{Auswahl der nachfolgenden Benchmarks}
\label{subsec:selectionNextBenchmark}

Zur Auswahl der Nachfolgenden \gls{Anwendung} dient die Methode \texttt{ChangeBenchmark()} des \texttt{BenchmarkController}s.
Hier wird mithilfe des Transitionssystems und unabhängig von anderen Clients bestimmt, welcher Benchmark ausgeführt werden soll und dieser in \texttt{CurrentBenchmark} gespeichert:

\begin{lstlisting}[label=lst:benchmarkChanging,style=cs,
caption={[Auswahl des nachfolgenden Benchmarks]
    Auswahl des nachfolgenden Benchmarks (gekürzt).
    Dies stellt einen Ausschnitt der Methode \texttt{ChangeBenchmark()} dar, welche vom Client zur Bestimmung des nachfolgenden Benchmarks aufgerufen wird (vgl. \cref{subsec:yarnClient}).}]
// g§§et probabilities f§§rom current benchmark
var transitions = BenchTransitions[CurrentBenchmark.Id];

// calculate next benchmark
var ranNumber = RandomGen.NextDouble();
var cumulative = 0D;
for(int i = 0; i < transitions.Length; i++)
{
  cumulative += transitions[i];
  if(ranNumber >= cumulative)
    continue;
  
  // prevent saving current benchmark a§§s previous
  if(CurrentBenchmark == _BenchmarksInstance[i])
    break;
  
  // save benchmarks
  PreviousBenchmark = CurrentBenchmark;
  CurrentBenchmark = Benchmarks[i];
  return true;
}
\end{lstlisting}

Bevor auf die Daten des implementierten Transitionssystems zugegriffen wird, wird außerdem zunächst geprüft, ob die Markow"=Kette alle möglichen Übergänge für den aktuellen Benchmark enthält.
Ist das nicht der Fall, wird eine \texttt{InvalidOperationException} ausgelöst.
Wenn die Auswahl des Benchmarks dagegen erfolgreich war, wird an den aufrufenden Client \texttt{true} zurückgegeben und der ausgewählte Benchmark kann gestartet werden (vgl. \cref{subsec:yarnClient}).

Der zur Auswahl des nachfolgenden Benchmarks benötigte Zufallsgenerator \texttt{Random""Gen} wird bei der Initialisierung des Benchmark"=Controllers basierend auf dem in \cref{subsec:testcaseGeneration} spezifizierten Basisseed initialisiert.
Damit die Benchmark"=Controller aller Clients nicht die gleichen Benchmarks auswählen, wird zum Basisseed die numerische ID des Clients addiert und der Zufallsgenerator mit diesem Wert initialisiert.
Als initiale \gls{Anwendung} wird zudem immer der \acrlong{sl}"=Benchmark genutzt, womit als erste \gls{Anwendung} immer eine \gls{Anwendung} ohne benötigte Eingabedaten gestartet wird (vgl. \cref{subsec:markovChain}).

\subsection{Vorabgenerierung von Eingabedaten}
\label{subsec:precreateInputData}

Neben der Generierung der für einige \glspl{Anwendung} benötigten Eingabedaten während der Testausführung gibt es auch die Möglichkeit, die Eingabedaten vorab zu generieren und anschließend immer diese zu nutzen.
Um die vorab generierten Daten in einem \gls{Test} zu nutzen, muss die entsprechende Eigenschaft \texttt{ModelSettings.IsPrecreateBenchInputs} auf \texttt{true} gesetzt werden.
Dadurch werden auch direkt die Eingabedaten generiert.

Die Vorabgenerierung der Daten startet die Anwendungen, welche Eingabedaten für andere \glspl{Anwendung} generieren und speichert diese in einem nur hierfür genutzten Verzeichnis im \gls{HDFS}.
Folgende fünf \glspl{Anwendung} reichen aus, um für alle anderen \glspl{Anwendung} Eingabedaten bereit zu stellen:

\begin{itemize}
    \item \acrlong{dfw}
    \item \acrlong{rtw}
    \item \acrlong{tg}
    \item \acrlong{so}
    \item \acrlong{tsr}
\end{itemize}

Gestartet werden kann die Vorabgenerierung mithilfe des Benchmark"=Controllers.
Hierbei werden die Anwendungen, sofern möglich, gleichzeitig ausgeführt und anschließend gewartet, bis alle fünf \glspl{Anwendung} beendet sind.
Hierbei wird standardmäßig die Generierung der Eingabedaten einer \gls{Anwendung} übersprungen, wenn das entsprechende Ausgabeverzeichnis der \gls{Anwendung} bereits existiert.

Es ist dabei jedoch möglich, die Verzeichnisse jeweils zu löschen, um somit die Daten vollständig neu zu generieren.
Hierbei wird zudem ein \gls{HDFS}"=Filecheck ausgeführt, um fehlerhafte Daten zu finden und zu löschen.
Fehlerhafte Daten können im \gls{HDFS} \zB dadurch entstehen, dass alle Nodes defekt sind, auf denen ein Block repliziert wurde, sich die Datei jedoch noch im Index des \gls{HDFS} befindet (vgl. \cref{sec:hadoop}.
Die vollständige Neugenerierung der Eingabedaten kann mithilfe der Eigenschaft \texttt{ModelSettings.IsPrecreateBenchInputsRecreate} gesteuert werden.

Um beim Starten der \glspl{Anwendung} die vorab generierten Eingabedaten zu nutzen, wird beim Starten der \glspl{Anwendung} das Verzeichnis der vorab generierten Daten als entsprechendes Client"=Verzeichnis genutzt (vgl. \cref{subsec:yarnClient,subsec:appImplementation}).
