\section{Betrachtung der \glsentryshort{MARP}"=Werte}
\label{sec:marpValueResults}

Bei der Betrachtung der \gls{MARP}"=Werte lässt sich generell sagen, dass die Selfbalancing"=Komponente den \gls{MARP}"=Wert entsprechend der Auslastung des Clusters anpasst.
Während bei allen Testkonfigurationen, bei denen Mutationen aktiv waren, der \gls{MARP}"=Wert unverändert blieb (vgl. \cref{sec:killingMutants}), wurde er bei 17 von 21 Ausführungen der 16 Konfigurationen ohne Mutationen verändert:

\begin{table}[h]
    \begin{tabular}{l|c|c|c|c|c|c|c}
    	Konf. &  1.1  &  1.2  &   3   &  5.1  &  5.2  &  7.1  &  7.2  \\ \hline
    	Wert  & 0,100 & 0,100 & 0,474 & 0,242 & 0,100 & 0,100 & 1,000 \\
    	\multicolumn{8}{c}{} \\
    	Konf. &  9.1  &  9.2  &  11   &  13   &  15   &  17   &  19   \\ \hline
    	Wert  & 0,269 & 0,175 & 0,539 & 0,356 & 0,368 & 0,731 & 0,430 \\
    	\multicolumn{8}{c}{} \\
    	Konf. &  21   &  23   &  25   &  27   &  29   & 31.1  & 31.2  \\ \hline
    	Wert  & 0,335 & 0,498 & 0,521 & ,0819 & 0,273 & 0,488 & 0,333
    \end{tabular}
    \caption[Finale \acrshort{MARP}"=Werte der \glspl{Testkonfiguration} ohne Mutanten.]
    {Finale \acrshort{MARP}"=Werte der \glspl{Testkonfiguration} ohne Mutanten. Die Übersicht der Tests findet sich in \cref{app:overviewExecutedTestCases}.}
    \label{tab:finalMarpValues}
\end{table}

Da er in den Konfigurationen 1 und 7 bei der jeweils ersten Ausführung nicht verändert wurde, wurden beide Konfigurationen erneut ausgeführt, wobei der \gls{MARP}"=Wert bei letzterem mehrmals erhöht wurde, bevor er im finalen Clusterstatus auf 1 gesetzt wurde.
Bei der Konfiguration 1 wurde der Wert dagegen bei keiner der beiden Ausführungen verändert.

Die nicht durchgeführte Änderung des \gls{MARP}"=Wertes in Konfiguration 1 liegt sehr wahrscheinlich daran, dass in hier nur im ersten der fünf \glspl{Testfall} zwei \glspl{Anwendung} gleichzeitig gestartet werden.
Dadurch wurden in allen 10 Testfällen zusammen nur 8 \glspl{Anwendung} gestartet, die Hälfte davon jeweils beim ersten Testfall.
Da zudem 4 der 8 \glspl{Anwendung} nur kleine \glspl{Anwendung} (\acrlong{rtw} und \acrlong{pi}) sind, und diese entsprechend schnell beendet werden können, steht den wesentlich ressourcenintensiveren \glspl{Anwendung} \acrlong{dfw} und \acrlong{dfr} das gesamte Cluster nahezu exklusiv zur Verfügung.
Daher stehen in diesen \glspl{Test} allen \glspl{Anwendung} ausreichend Ressourcen zur Verfügung, was eine Anpassung des \gls{MARP}"=Wertes unnötig erscheinen lässt und daher durch die Selfbalancing"=Komponente nicht durchgeführt wird.

Bei der \gls{Testkonfiguration} 7 ist dies ähnlich, wobei die gesamte Last auf mehr Nodes verteilt werden kann.
Der \gls{Test} 7.2 und der hier deutlich veränderte \gls{MARP}"=Wert im Vergleich zu \gls{Test} 7.1 ohne Anpassung zeigt jedoch auch, dass es stark abhängig davon ist, wie die Last im Cluster verteilt wird.
Bestätigt wird dies durch die \glspl{Test} 9.1 und 9.2, da bei letzterem weniger Komponentenfehler injiziert wurden und sich die Last entsprechend auf mehr aktive Nodes verteilen konnte.
Dadurch war im \gls{Test} 9.2 ein um rund 0,1 niedrigerer \gls{MARP}"=Wert als im \gls{Test} 9.1 nötig.

Auffällig war zudem, dass der \gls{MARP}"=Wert in den Testausführungen 7.2, 9.1 und 23 nicht direkt im ersten \gls{Testfall} verändert wurde, sondern erst bei der Ausführung von Testfällen im späteren Verlauf der jeweiligen Tests.
Als Resultat wurde daher in 9 der 15 \glspl{Testfall} der drei Testausführungen zunächst das hierfür genutzte Constraint als ungültig validiert.
