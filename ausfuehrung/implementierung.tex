\section{Implementierung der Simulation}\label{sec:implSimulation}

Wie bereits erwähnt, wurden zwei grundlegende Tests implementiert.
Das ist zum einen die Simulation, bei der ein Testfall ohne die Aktivierung von Komponentenfehler ausgeführt wird, sowie der Analysetest, bei dem Komponentenfehler aktiviert werden.

\subsection{Grundlegender Aufbau}\label{sec:simulationBasics}

\todo{Anpassen wenn Stand der Technik mit \sS-Einführung geschrieben ist}
Die Simulation ist die einfache Ausführung eines Testfalls ohne die Aktivierung der implementierten Komponentenfehlern oder der Erzeugung von weiteren Fehlern im realen Cluster.
Der \sS-Simulator unterstützt eine Simulation in einzelnen oder mehreren Schritten, zwischen denen in reinen Modellen beliebig gewechselt werden kann.
Da hier jedoch ein reales System getestet wird, wird jeder Schritt einzeln ausgeführt.

Da im realen Cluster Hadoop kontinuierlich Anpassungen durchführt und Tests in \sS mit diskreten Schritten durchgeführt werden, muss beachtet werden, dass die Werte, die beim Test ermittelt werden, immer nur Momentaufnahmen darstellen.
Ebenso muss beachtet werden, dass bei der Deaktivierung von einzelnen Nodes bzw. deren Netzwerkverbindungen diese nicht in Echtzeit, sondern um einige Zeit verzögert erkannt werden und erst nach einer gewissen Zeit aus der Konfiguration des Clusters entfernt werden.
Genauso verhält es sich, wenn ein Node bzw. seine Verbindung wieder aktiviert wird, da dieser zunächst selbst starten muss und sich mit dem YARN"=Controller verbinden muss.
Außerdem werden die für die auf dem Cluster ausgeführten Anwendungen benötigten \ac{AppMstr} und YARN"=Container aufgrund der komplexen internen Prozesse von Hadoop nicht innerhalb weniger Millisekunden allokiert, sondern benötigen ebenfalls eine gewisse Zeit.
Aus diesen Gründen darf ein Schritt nicht zu schnell vorüber sein.

\lstinputlisting[label=lst:hadoopSimulation,style=cs,
caption={[Simulation in dieser Fallstudie]
    Simulation in dieser Fallstudie (gekürzt).}]
{./listings/hadoopSimulation.cs}

\autoref{lst:hadoopSimulation} zeigt den Ablauf einer Hadoop"=Simulation.
Da der Ablauf der Simulation unabhängig von der Aktivierung der Komponentenfehler der gleiche ist, ist hier nur die Variante ohne deren Aktivierung aufgezeigt.
Im Falle einer Aktivierung der Komponentenfehler unterscheiden sich beide Simulationsvarianten nur durch die Angabe der Wahrscheinlichkeiten zum Aktivieren und Deaktivieren der Komponentenfehler sowie des Übergabeparameters an \texttt{ExecuteSimulation()}.
Da die einzelnen Schritte einer Simulation eine gewisse Mindestdauer haben, wird nach jedem Schritt geprüft, wie viel Zeit für die Ausführung des Schrittes benötigt wurde.
Liegt die Zeit unterhalb der Mindestdauer für einen Schritt, wird die Ausführung des nächsten Schrittes solange hinausgezögert, bis die Mindestdauer des Schrittes erreicht wurde.

Wenn während der Simulation eine im Modell nicht behandelte \texttt{Exception} auftritt, dann wird diese außerhalb der Simulation abgefangen und geloggt.
Dadurch wird zudem die Simulation beim aktuellen Stand abgebrochen und unabhängig von aufgetretenen \texttt{Exception}s Nodes mit injizierten Komponentenfehlern neu gestartet.

\subsection{Initialisierung des Modells}\label{sec:simulationModelInit}

Bevor das Modell im Simulator ausgeführt werden kann, muss es initialisiert werden.
Das folgende \autoref{lst:hadoopSimulationInit} zeigt die Definition der Variablen zur Modellinitialisierung sowie die entsprechenden Methoden, die in \autoref{lst:hadoopSimulation} zur Initialisierung aufgerufen werden:

\lstinputlisting[label=lst:hadoopSimulationInit,style=cs,
caption={Initialisierung des Modells für die Simulation}]
{./listings/hadoopSimulationInit.cs}

Die einzelnen Variablen für die Simulation werden statisch definiert und beim Initialisieren des Modells in den \texttt{ModelSettings} gespeichert.
Die dort gespeicherten Werte werden anschließend beim Initialisieren der Modell"=Instanz bzw. während der Ausführung der Simulation genutzt.

Einige Variablen haben lediglich einen Zweck, während andere umfangreichere Auswirkungen besitzen.
Die einfachen Variablen sind:

\begin{description}
    \item [\_MinStepTime]
        Definiert die Mindestdauer eines Schrittes.
    \item[\_BenchmarkSeed]
        Gibt den Seed an, mit dem die Zufallsgeneratoren in den Klassen \texttt{BenchmarkController} und \texttt{NodeFaultAttribute} initialisiert werden.
        Dadurch wird es ermöglicht, einzelne Testfälle erneut ausführen zu können.
    \item[\_StepCount]
        Definiert die Anzahl der ausgeführten Schritte.
    \item[\_FaultActivationProbability]
        Definiert die generelle Häufigkeit zum Aktivieren von Komponentenfehlern.
        Ist dieser Wert 0,0, werden grundsätzlich keine Komponentenfehler aktiviert, bei einem Wert von 1,0 werden Komponentenfehler dagegen immer aktiviert.
    \item[\_FaultRepariProbability]
        Definiert die generelle Häufigkeit zum Deaktivieren von Komponentenfehlern.
        Die hier definierte Wahrscheinlichkeit verhält sich analog zu \texttt{\_FaultActivationProbability}.
        Bei einem Wert von 0,0 werden Komponentenfehler niemals deaktiviert, während sie bei einem Wert von 1,0 im nachfolgenden Schritt immer deaktiviert werden.
    \item[\_HostsCount]
        Definiert die Anzahl der in der Simulation verwendeten Hosts.
        Benötigt wird dieser Wert, damit zu jedem verwendeten Host eine SSH"=Verbindung aufgebaut werden kann.
    \item[\_NodeBaseCount]
        Definiert die Anzahl der Nodes auf Host1.
        Auf Host2 wird die Hälfte der Nodes verwendet.
        Benötigt wird dieser Wert, um mithilfe der REST"=API auf die Hadoop"=Nodes zugreifen zu können, um die Daten der YARN"=Container zu ermitteln.
    \item[\_ClientCount]
        Definiert die Anzahl der zu simulierenden Clients.
        Da jeder Client gleichzeitig nur eine Anwendung startet, wird dadurch gleichzeitig definiert, wie viele Anwendungen gleichzeitig auf dem Cluster ausgeführt werden sollen.
\end{description}

Eine Besonderheit bildet die Variable \texttt{\_PrecreatedInputs}.
Sie definiert, ob die ausgeführten Anwendungen auf dem Cluster vorab generierte Eingabedaten nutzen oder alle Eingabedaten während der Ausführung selbst generieren.
Der Unterschied zwischen beiden Varianten liegt darin, dass vorab generierte Eingabedaten in einem anderen Verzeichnis im \ac{HDFS} gespeichert sind und während der Simulation die Eingabedaten aus diesem Verzeichnis gelesen werden.
Wenn keine Eingabedaten vorab generiert werden, werden als Eingabeverzeichnisse für die Anwendungen die Ausgabeverzeichnisse der entsprechenden Benchmarks genutzt, die die dafür benötigten Daten generieren.
Der genaue Ablauf der Bereitstellung der Eingabedaten wird in \todo{Vorabgenerierung der Eingabedaten irgendwo schreiben und hier drauf verweisen} beschrieben.

Die Auswirkungen der in \texttt{InitModel()} definierten Einstellung \texttt{ModelSettings.Host""Mode} wird in \todo{ModelSettings.HostMode beschrieben und hier verweisen} beschrieben.

Die direkt im Anschluss an die Initialisierung des Simulators ausgerufene Methode \texttt{CollectYarnNodeFaults()} ermittelt alle im Modell enthaltenen Komponentenfehler, die mit dem \texttt{NodeFaultAttribute} markiert sind.
Die gefundenen Komponentenfehler werden als Array aus Tupel, bestehend aus dem Komponentenfehler selbst, dem Attribut sowie dem dazugehörigen Node zurückgegeben.
Die jeweiligen Instanzen der Attribute und Nodes werden für die in \autoref{sec:simulationFaultActivation} beschriebene Aktivierung der dazugehörigen Komponentenfehler benötigt.

\subsection{Ablauf eines Simulations"=Schrittes}\label{sec:simulationStep}

Der Ablauf eines Schrittes lässt sich in die folgenden fünf Abschnitte einteilen.
Während die \nameref{sec:simulationFaultActivation} komplett außerhalb des Modells und durch den Simulator erfolgt, werden die anderen Abschnitte durch den \texttt{YarnController} innerhalb des Modells während der Ausführung eines Simulations"=Schrittes durchgeführt.
Die \nameref{sec:simulationStepOutput} werden direkt von den jeweils betroffenen Komponenten im Rahmen des normalen Loggings durchgeführt.

\subsubsection{Aktivierung und Deaktivierung der Komponentenfehler}\label{sec:simulationFaultActivation}

Die Aktivierung der Komponentenfehler läuft in jeweils drei Schritten ab.
Der erste Schritt ist die Prüfung, ob der Fehler bereits aktiviert wurde.
Bei einem derzeit nicht injizierten Komponentenfehler, wird im zweiten Schritt geprüft, ob der Fehler aktiviert werden soll bevor er im dritten Schritt aktiviert und damit zur Injizierung im realen Cluster durch den \sS"=Simulator freigegeben wird.

Zur Entscheidung, ob ein Komponentenfehler aktiviert wird, hängt von folgenden Parametern ab:

\begin{itemize}
    \item Von der Auslastung des Nodes im vorhergehenden Simulationsschritt,
    \item von der in \texttt{ModelSettings.FaultActivationProbability} definierten generellen Wahrscheinlichkeit zur Fehleraktivierung,
    \item sowie von einer Zufallszahl.
\end{itemize}

Zur Entscheidung, ob ein Komponentenfehler aktiviert wird, werden diese Parameter miteinander verrechnet und somit Entschieden, ob er aktiviert wird:

\begin{algorithm}
    \label{alg:faultActivation}
    \caption{Entscheidung zur Aktivierung von Komponentenfehlern}
    \begin{algorithmic}[1]
        \STATE $nodeUsage \gets (memUsage + cpuUsage) / 2$
        \IF{$nodeUsage < 0.1$}
            \STATE $nodeUsage \gets 0.1$
        \ENDIF
        \IF{$nodeUsage > 0.9$}
            \STATE $nodeUsage \gets 0.9$
        \ENDIF
        \STATE $faultProbability \gets 1 - (nodeUsage * ActivationProbability * 2)$
        \STATE $randomValue \gets GetRandomDouble()$
        \IF{$faultProbability < randomValue$}
            \RETURN \TRUE \COMMENT{Activate}
        \ELSE
            \RETURN \FALSE \COMMENT{No activation}
        \ENDIF
    \end{algorithmic}
\end{algorithm}

Die Entscheidung zur Deaktivierung eines Komponentenfehlers verhält sich analog.
Anstatt der generellen Aktivierungswahrscheinlichkeit in \texttt{ModelSettings.Fault""ActivationProbability} wird die generelle Wahrscheinlichkeit zur Deaktivierung in \texttt{ModelSettings.FaultRepairProbability} genutzt.
Außerdem spielt bei der Deaktivierung die Auslastung des Nodes zum Zeitpunkt der Aktivierung eine Rolle.
Der grundlegende Algorithmus zur Entscheidung ist jedoch gleich.

\subsubsection{Ausführung Benchmarks}\label{sec:simulationBenchmarkExecution}


\subsubsection{Monitoring der ausgeführten Anwendungen}\label{sec:simulationMonitoring}


\subsubsection{Prüfungen durch das Oracle}\label{sec:simulationOracle}


\subsubsection{Ausgaben während eines Schrittes}\label{sec:simulationStepOutput}


\subsection{Weitere Möglichkeiten der Simulation}\label{sec:simulationUtilities}
% noch nicht genannte Methoden/Tests erklären