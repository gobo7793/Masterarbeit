\section{Implementierung der Simulation}\label{sec:implSimulation}

Wie bereits erwähnt, wurden zwei grundlegende Tests implementiert.
Das ist zum einen die Simulation, bei der ein Testfall ohne die Aktivierung von Komponentenfehler ausgeführt wird, sowie der Analysetest, bei dem Komponentenfehler aktiviert werden.

\subsection{Grundlegender Aufbau}\label{sec:simulationBasics}

\todo{Anpassen wenn Stand der Technik mit \sS-Einführung geschrieben ist}
Die Simulation ist die einfache Ausführung eines Testfalls ohne die Aktivierung der implementierten Komponentenfehlern oder der Erzeugung von weiteren Fehlern im realen Cluster.
Der \sS-Simulator unterstützt eine Simulation in einzelnen oder mehreren Schritten, zwischen denen in reinen Modellen beliebig gewechselt werden kann.
Da hier jedoch ein reales System getestet wird, wird jeder Schritt einzeln ausgeführt.

Da im realen Cluster Hadoop kontinuierlich Anpassungen durchführt und Tests in \sS mit diskreten Schritten durchgeführt werden, muss beachtet werden, dass die Werte, die beim Test ermittelt werden, immer nur Momentaufnahmen darstellen.
Ebenso muss beachtet werden, dass bei der Deaktivierung von einzelnen Nodes bzw. deren Netzwerkverbindungen diese nicht in Echtzeit, sondern um einige Zeit verzögert erkannt werden und erst nach einer gewissen Zeit aus der Konfiguration des Clusters entfernt werden.
Genauso verhält es sich, wenn ein Node bzw. seine Verbindung wieder aktiviert wird, da dieser zunächst selbst starten muss und sich mit dem YARN"=Controller verbinden muss.
Außerdem werden die für die auf dem Cluster ausgeführten Anwendungen benötigten \ac{AppMstr} und YARN"=Container aufgrund der komplexen internen Prozesse von Hadoop nicht innerhalb weniger Millisekunden allokiert, sondern benötigen ebenfalls eine gewisse Zeit.
Aus diesen Gründen darf ein Schritt nicht zu schnell vorüber sein.

\lstinputlisting[label=lst:hadoopSimulation,style=cs,
caption={[Simulation in dieser Fallstudie]
    Simulation in dieser Fallstudie (gekürzt).}]
{./listings/hadoopSimulation.cs}

\autoref{lst:hadoopSimulation} zeigt den Ablauf einer Hadoop"=Simulation.
Da der Ablauf der Simulation unabhängig von der Aktivierung der Komponentenfehler der gleiche ist, ist hier nur die Variante ohne deren Aktivierung aufgezeigt.
Im Falle einer Aktivierung der Komponentenfehler unterscheiden sich beide Simulationsvarianten nur durch die Angabe der Wahrscheinlichkeiten zum Aktivieren und Deaktivieren der Komponentenfehler sowie des Übergabeparameters an \texttt{ExecuteSimulation()}.
Da die einzelnen Schritte einer Simulation eine gewisse Mindestdauer haben, wird nach jedem Schritt geprüft, wie viel Zeit für die Ausführung des Schrittes benötigt wurde.
Liegt die Zeit unterhalb der Mindestdauer für einen Schritt, wird die Ausführung des nächsten Schrittes solange hinausgezögert, bis die Mindestdauer des Schrittes erreicht wurde.

Wenn während der Simulation eine im Modell nicht behandelte \texttt{Exception} auftritt, dann wird diese außerhalb der Simulation abgefangen und geloggt.
Dadurch wird zudem die Simulation beim aktuellen Stand abgebrochen und unabhängig von aufgetretenen \texttt{Exception}s Nodes mit injizierten Komponentenfehlern neu gestartet.

\subsection{Initialisierung des Modells}\label{sec:simulationModelInit}

Bevor das Modell im Simulator ausgeführt werden kann, muss es initialisiert werden.
Das folgende \autoref{lst:hadoopSimulationInit} zeigt die Definition der Variablen zur Modellinitialisierung sowie die entsprechenden Methoden, die in \autoref{lst:hadoopSimulation} zur Initialisierung aufgerufen werden:

\lstinputlisting[label=lst:hadoopSimulationInit,style=cs,
caption={Initialisierung des Modells für die Simulation}]
{./listings/hadoopSimulationInit.cs}

Die einzelnen Variablen für die Simulation werden statisch definiert und beim Initialisieren des Modells in den \texttt{ModelSettings} gespeichert.
Die dort gespeicherten Werte werden anschließend beim Initialisieren der Modell"=Instanz bzw. während der Ausführung der Simulation genutzt.

Einige Variablen haben lediglich einen Zweck, während andere umfangreichere Auswirkungen besitzen.
Die einfachen Variablen sind:

\begin{description}
    \item [\_MinStepTime]
        Definiert die Mindestdauer eines Schrittes.
    \item[\_BenchmarkSeed]
        Gibt den Seed an, mit dem die Zufallsgeneratoren in den Klassen \texttt{BenchmarkController} und \texttt{NodeFaultAttribute} initialisiert werden.
        Dadurch wird es ermöglicht, einzelne Testfälle erneut ausführen zu können.
    \item[\_StepCount]
        Definiert die Anzahl der ausgeführten Schritte.
    \item[\_FaultActivationProbability]
        Definiert die grundlegende Häufigkeit zum Injizieren von Komponentenfehlern.
    \item[\_FaultRepariProbability]
        Definiert die grundlegende Häufigkeit zum Deaktivieren von Komponentenfehlern.
    \item[\_HostsCount]
        Definiert die Anzahl der in der Simulation verwendeten Hosts.
        Benötigt wird dieser Wert, damit zu jedem verwendeten Host eine SSH"=Verbindung aufgebaut werden kann.
    \item[\_NodeBaseCount]
        Definiert die Anzahl der Nodes auf Host1.
        Auf Host2 wird die Hälfte der Nodes verwendet.
        Benötigt wird dieser Wert, um mithilfe der REST"=API auf die Hadoop"=Nodes zugreifen zu können, um die Daten der YARN"=Container zu ermitteln.
    \item[\_ClientCount]
        Definiert die Anzahl der zu simulierenden Clients.
        Da jeder Client gleichzeitig nur eine Anwendung startet, wird dadurch gleichzeitig definiert, wie viele Anwendungen gleichzeitig auf dem Cluster ausgeführt werden sollen.
\end{description}

Eine Besonderheit bildet die Variable \texttt{\_PrecreatedInputs}.
Sie definiert, ob die ausgeführten Anwendungen auf dem Cluster vorab generierte Eingabedaten nutzen oder alle Eingabedaten während der Ausführung selbst generieren.
Der Unterschied zwischen beiden Varianten liegt darin, dass vorab generierte Eingabedaten in einem anderen Verzeichnis im \ac{HDFS} gespeichert sind und während der Simulation die Eingabedaten aus diesem Verzeichnis gelesen werden.
Wenn keine Eingabedaten vorab generiert werden, werden als Eingabeverzeichnisse für die Anwendungen die Ausgabeverzeichnisse der entsprechenden Benchmarks genutzt, die die dafür benötigten Daten generieren.
Der genaue Ablauf der Bereitstellung der Eingabedaten wird in \todo{Vorabgenerierung der Eingabedaten irgendwo schreiben und hier drauf verweisen} beschrieben.

Die Auswirkungen der in \texttt{InitModel()} definierten Einstellung \texttt{ModelSettings.HostMode} wird in \todo{ModelSettings.HostMode beschrieben und hier verweisen} beschrieben.

\subsection{Ablauf eines Simulations"=Schrittes}\label{sec:simulationStep}

Der Ablauf eines Schrittes lässt sich in die folgenden fünf Abschnitte einteilen.
Während die \nameref{sec:simulationFaultActivation} komplett außerhalb des Modells durch den Simulator erfolgt, werden die anderen Abschnitte durch den \texttt{YarnController} innerhalb des Modells durchgeführt.
Die \nameref{sec:simulationStepOutput} werden direkt von den jeweils betroffenen Komponenten im Rahmen des normalen Loggings durchgeführt.

\subsubsection{Aktivierung der Komponentenfehler}\label{sec:simulationFaultActivation}



\subsubsection{Ausführung Benchmarks}\label{sec:simulationBenchmarkExecution}


\subsubsection{Monitoring der ausgeführten Anwendungen}\label{sec:simulationMonitoring}


\subsubsection{Prüfungen durch das Oracle}\label{sec:simulationOracle}


\subsubsection{Ausgaben während eines Schrittes}\label{sec:simulationStepOutput}


\subsection{Weitere Möglichkeiten der Simulation}\label{sec:simulationUtilities}
% noch nicht genannte Methoden/Tests erklären